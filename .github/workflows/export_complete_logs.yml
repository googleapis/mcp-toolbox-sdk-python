# Copyright 2025 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

name: Export Complete Build Logs 
# detects PR test failures and exports complete logs
on:
  workflow_dispatch:
    inputs:
      name:
        description: 'Simulated check run name (optional)'
        required: false
      details_url:
        description: 'Simulated details_url (optional)'
        required: false
  pull_request:
    types: [synchronize, opened, reopened]
  check_run:
    types: [completed]

jobs:
  export-logs:
    # Run for manual dispatch (for sandbox testing), or for PRs from this fork,
    # or for failed Cloud Build PR tests (production path).
    if: >
      github.event_name == 'workflow_dispatch' ||
      (
        github.event_name == 'pull_request' &&
        github.event.pull_request &&
        github.event.pull_request.head &&
        github.event.pull_request.head.repo &&
        github.event.pull_request.head.repo.full_name == 'Ganga4060/mcp-toolbox-sdk-python'
      ) ||
      (github.event.check_run.conclusion == 'failure' && contains(github.event.check_run.name, '-pr-'))
    
    permissions:
      contents: 'write'
      checks: 'write'  # Need this to update check runs
    
    runs-on: ubuntu-latest
    
    steps:
      # Step 1: Detect and validate the failure
      - name: Process PR test failure
        id: detect
        uses: 'actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd' # v8
        with:
          script: |
            // Script for Cloud Build PR test failures
            // `actions/github-script` injects `core` and `context` into the script scope,
            // so don't redeclare `core` here or it will throw: "Identifier 'core' has
            // already been declared". Use the injected `core` directly.
            try {
              // Allow reassignment if we discover a check run via the REST API
              let checkRun = context.payload.check_run || {};

            // If this run was triggered manually via workflow_dispatch, allow passing
            // simulated inputs (name, details_url) so sandbox testing can exercise
            // the same detection logic. workflow_dispatch inputs are in context.payload.inputs
            if (!checkRun.name && context.eventName === 'workflow_dispatch') {
              const inputs = context.payload && context.payload.inputs ? context.payload.inputs : {};
              checkRun.name = inputs.name || '';
              checkRun.details_url = inputs.details_url || '';
            }
            const checkNameRaw = checkRun.name || '';
            // Remove trailing parenthetical suffixes like ' (toolbox-testing-438616)'
            const checkNameStripped = checkNameRaw.replace(/\s*\(.*\)$/, '');
            const checkName = checkNameStripped.toLowerCase();
            const detailsUrlRaw = checkRun.details_url || '';
            const detailsUrl = detailsUrlRaw.toLowerCase();

            console.log(`Processing check: ${checkNameRaw}`);

            // Hardcoded whitelist of PR test names (base names without project
            // parenthetical). This mirrors the required status checks in
            // `.github/sync-repo-settings.yaml` so we only export logs for those
            // exact tests used by the repo.
            const baseWhitelist = [
              'core-python-sdk-pr-py313',
              'core-python-sdk-pr-py312',
              'core-python-sdk-pr-py311',
              'core-python-sdk-pr-py310',
              'core-python-sdk-pr-py39',
              'langchain-python-sdk-pr-py313',
              'langchain-python-sdk-pr-py312',
              'langchain-python-sdk-pr-py311',
              'langchain-python-sdk-pr-py310',
              'langchain-python-sdk-pr-py39',
              'llamaindex-python-sdk-pr-py313',
              'llamaindex-python-sdk-pr-py312',
              'llamaindex-python-sdk-pr-py311',
              'llamaindex-python-sdk-pr-py310',
              'llamaindex-python-sdk-pr-py39'
            ];

            const looksLikePrName = baseWhitelist.includes(checkNameStripped.toLowerCase());
            console.log(`Whitelist contains ${baseWhitelist.length} entries; name match = ${looksLikePrName}`);

            // If this was triggered by a pull_request event, there's no
            // `check_run` payload. Try to find a failed check run for the PR
            // commit SHA that matches our whitelist using the Checks API.
            if (!checkRun.name && context.eventName === 'pull_request') {
              const headSha = context.payload.pull_request && context.payload.pull_request.head && context.payload.pull_request.head.sha;
              console.log(`pull_request event detected, head SHA = ${headSha}`);
              if (headSha) {
                const resp = await github.rest.checks.listForRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: headSha,
                });
                const runs = resp.data && resp.data.check_runs ? resp.data.check_runs : [];
                console.log(`Found ${runs.length} check runs for ref ${headSha}`);
                for (const r of runs) {
                  const nameStripped = (r.name || '').replace(/\s*\(.*\)$/, '').toLowerCase();
                  const isWhitelisted = baseWhitelist.includes(nameStripped);
                  const isFailure = r.conclusion === 'failure' || r.conclusion === 'cancelled' || r.conclusion === 'timed_out';
                  const urlOk = r.details_url && /cloudbuild|cloud-build|console.cloud.google.com\/cloud-build|cloudbuild.googleapis.com/.test((r.details_url || '').toLowerCase());
                  // Debug: print info for each check run so we can see why none matched
                  console.log(`check-run: id=${r.id} name='${r.name}' conclusion='${r.conclusion}' details_url='${r.details_url}' whitelisted=${isWhitelisted} failure=${isFailure} urlOk=${urlOk}`);
                  if (isWhitelisted && isFailure && urlOk) {
                    console.log(`Selected check run '${r.name}' (id=${r.id}) from PR for export`);
                    checkRun = r;
                    break;
                  }
                }
              }
            }
            console.log(`Whitelist contains ${baseWhitelist.length} entries; name match = ${looksLikePrName}`);

            // Ensure the details URL points to Cloud Build to avoid false positives
            const isCloudBuildUrl = /cloudbuild|cloud-build|console.cloud.google.com\/cloud-build|cloudbuild.googleapis.com/.test(detailsUrl);

            if (!looksLikePrName || !isCloudBuildUrl) {
              console.log(`Skipping non-Cloud Build or non-PR check: name='${checkNameRaw}' url='${detailsUrlRaw}'`);
              core.setOutput('should_export', 'false');
              return;
            }

            console.log(`Processing failed Cloud Build PR test: ${checkNameRaw}`);

            // Extract build ID from Cloud Build URL using a few common patterns
            let buildId = null;
            if (detailsUrlRaw) {
              console.log(`Checking URL: ${detailsUrlRaw}`);
              const buildIdPatterns = [
                /\/builds\/([a-f0-9-]+)/i,           // Standard Cloud Build pattern
                /buildId=([a-f0-9-]+)/i,              // Query parameter pattern
                /\/builds\/(\d+)/                    // Numeric build ID
              ];

              for (const pattern of buildIdPatterns) {
                const match = detailsUrlRaw.match(pattern);
                if (match && match[1]) {
                  buildId = match[1];
                  console.log(`Extracted build ID: ${buildId}`);
                  break;
                }
              }
            }

            if (!buildId) {
              console.log(`Could not extract build ID from: ${detailsUrlRaw}`);
              core.setOutput('should_export', 'false');
              return;
            }

            // Set outputs for next steps
            const sanitizedName = checkNameRaw.replace(/[^a-zA-Z0-9_-]/g, '-');
            core.setOutput('should_export', 'true');
            core.setOutput('build_id', buildId);
            core.setOutput('test_name', sanitizedName);
            core.setOutput('original_name', checkNameRaw);

            console.log(`Ready to export logs for ${checkNameRaw}`);
            console.log(`Artifact will be: complete-logs-${sanitizedName}`);
            } catch (err) {
              // On any unexpected error in detection, don't fail the job. Instead,
              // mark that we should not export and continue. This avoids causing
              // the job to fail and skipping downstream jobs/steps unexpectedly.
              console.error('Error during detect step:', err && err.stack ? err.stack : err);
              try {
                core.setOutput('should_export', 'false');
              } catch (innerErr) {
                // core may not be available in some execution contexts; if it's not,
                // log and continue. The workflow will skip export steps based on this.
                console.error('Failed to set output should_export:', innerErr);
              }
            }

      # Step 2: Fetch complete logs from Cloud Build
      - name: Authenticate to Google Cloud
        if: steps.detect.outputs.should_export == 'true'
        uses: google-github-actions/auth@v2
        with:
          credentials_json: ${{ secrets.CLOUD_BUILD_LOG_VIEWER_SA_KEY }}

      - name: Setup gcloud
        if: steps.detect.outputs.should_export == 'true'
        uses: google-github-actions/setup-gcloud@v2

      - name: Fetch complete logs
        if: steps.detect.outputs.should_export == 'true'
        run: |
          echo " Fetching complete logs for build: ${{ steps.detect.outputs.build_id }}"
          echo " Test: ${{ steps.detect.outputs.original_name }}"
          echo " Project: toolbox-testing-438616"
          
          # Fetch complete logs from Cloud Build (untruncated)
          if gcloud builds log "${{ steps.detect.outputs.build_id }}" \
              --project="toolbox-testing-438616" > complete-logs.txt 2>&1; then
            
            LOG_SIZE=$(wc -c < complete-logs.txt)
            echo "Successfully fetched complete logs (${LOG_SIZE} bytes)"
            
            if [ $LOG_SIZE -eq 0 ]; then
              echo "Warning: Log file is empty" > complete-logs.txt
              echo "This might indicate the build is still running or the build ID is incorrect." >> complete-logs.txt
            fi
            
          else
            echo "Failed to fetch build logs" > complete-logs.txt
            echo "" >> complete-logs.txt
            echo "Build ID: ${{ steps.detect.outputs.build_id }}" >> complete-logs.txt
            echo "Project: toolbox-testing-438616" >> complete-logs.txt
            echo "" >> complete-logs.txt
            echo "This might be due to:" >> complete-logs.txt
            echo "1. Build ID does not exist" >> complete-logs.txt
            echo "2. Build is still in progress" >> complete-logs.txt
            echo "3. Insufficient permissions" >> complete-logs.txt
          fi

      # Step 3: Upload logs and create accessible download link
      - name: Upload complete logs artifact
        if: steps.detect.outputs.should_export == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: complete-logs-${{ steps.detect.outputs.test_name }}
          path: complete-logs.txt
          retention-days: 30

      - name: Create direct download link via GitHub release
        if: steps.detect.outputs.should_export == 'true'
        run: |
          # Create a unique filename for the logs
          LOG_FILE="complete-logs-${{ steps.detect.outputs.test_name }}-$(date +%Y%m%d-%H%M%S).txt"
          cp complete-logs.txt "$LOG_FILE"
          
          # Create or update a release for log storage
          RELEASE_TAG="build-logs-$(date +%Y%m%d)"
          
          # Check if release exists, create if not
          if ! gh release view "$RELEASE_TAG" >/dev/null 2>&1; then
            gh release create "$RELEASE_TAG" \
              --title "Build Logs $(date +%Y-%m-%d)" \
              --notes "Automated release for storing complete build logs" \
              --prerelease
          fi
          
          # Upload log file to release
          gh release upload "$RELEASE_TAG" "$LOG_FILE" --clobber
          
          # Get download URL
          DOWNLOAD_URL="https://github.com/${{ github.repository }}/releases/download/$RELEASE_TAG/$LOG_FILE"
          echo "DOWNLOAD_URL=$DOWNLOAD_URL" >> $GITHUB_ENV
          echo "LOG_FILENAME=$LOG_FILE" >> $GITHUB_ENV
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      # Step 4: Add download link to existing failed check run
      - name: Add complete logs check run
        if: steps.detect.outputs.should_export == 'true'
        uses: 'actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd' # v8
        with:
          script: |
            const testName = '${{ steps.detect.outputs.original_name }}';
            const downloadUrl = process.env.DOWNLOAD_URL;
            const buildId = '${{ steps.detect.outputs.build_id }}';

            // Modify original Cloud Build check run only (no fallback)
            const checkRunId = context.payload.check_run.id;
            const originalOutput = context.payload.check_run.output || {};

            // preserve existing title/summary/text
            const originalTitle = originalOutput.title || 'Build details';
            const originalSummary = originalOutput.summary || '';
            let originalText = originalOutput.text || '';

            const linkLine = `- Complete logs: ${downloadUrl}`;
            const sectionHeaderRegex = /(^|\n)(\s*Cloud Build links\s*[:\n])/i;

            if (sectionHeaderRegex.test(originalText)) {
              // insert link after the header line
              originalText = originalText.replace(sectionHeaderRegex, (m, p1, p2) => `${p1}${p2}\n${linkLine}\n`);
            } else {
              // append a Cloud Build links section at the end
              originalText = `${originalText}\n\nCloud Build links:\n${linkLine}\n`;
            }

            // Update check run output, preserving title and summary
            await github.rest.checks.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              check_run_id: checkRunId,
              output: {
                title: originalTitle,
                summary: originalSummary,
                text: originalText
              }
            });

            console.log(`Successfully appended download link to check run ${checkRunId}`);
            console.log(`Download link available: ${downloadUrl}`);


